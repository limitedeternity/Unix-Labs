# Unix 2023 HW1

Правила сдачи задания:

- Максимальное количество баллов — 10.

- Все решения должны быть доступны для запуска как самостоятельные программы.

- Задача не считается выполненной, если не были использованы все перечисленные в списке "Необходимо
  использовать" механизмы (кроме случаев, когда вы предложили более элегантное решение).

- Каждая задача выполняется в соответствующем файле из уже существующих в репозитории.

- Те задачи, для которых представлены тесты, требуют прохождения тестов в CI для сдачи.

- Все задачи требуют прохождения ручной проверки для сдачи.

## Консольный помощник (3 балла)

Реализуйте shell-скрипт, принимающий в качестве аргументов shell-команду и запускающий её.

Первый аргумент — команда, остальные аргументы — её аргументы.

Потоки вывода запущенной команды кроме stdout не обрабатываются.

Стандартный поток вывода сохраняется, но не выводится на экран.

Первой строкой вывода необходимо напечатать код возврата выполненной команды (желательно с
текстовым пояснением для пользователя).

Если вывод пустой, ничего не делаем.

Если не пустой, выводится приглашение ко вводу (без перевода строки) вида
`How to show result (p/e/o/n): `.

После этого считывается ввод пользователя. Если пользователь ввёл:

- `p` — открыть вывод команды в пейджере
- `e` — открыть вывод команды в редакторе
- `o` — вывести вывод в стандартный поток вывода
- `n` — ничего не делать
- иначе вывести подсказку по командам и перезапросить ввод (не забудьте про приглашение!)

Возможность приёма командой ввода не предусмотрена и должна быть заблокирована.

**Необходимо использовать:** `case`, `while`, `read`, `printf`, `mktemp`,
перенаправление ввода-вывода, системные файлы (`/dev/null`),
переменные окружения (`PAGER`, `EDITOR`).

**Файл:** [assist.sh](./src/assist.sh).

### Пример

```
$ ./assist.sh du -d 1 -h
Command finished with code: 0
Display output in: (e/p/o/n/?) sdfdf
e - open in editor
p - open in pager
o - print to stdout
n - do nothing
Display output in: (e/p/o/n/?) o
124K    ./hw1
196K    .
```

## Rand (1 балл)

Написать команду, которая будет получать в качестве единственного аргумента командной строки
название файла и создавать его.

Размер файла — случайное число байт.
Файл должен быть полностью заполнен случайными байтами.
Размер можно вычислять заранее, запоминая результат в переменной.

**Необходимо использовать:** `dd`, системный файл `/dev/urandom`.

**Подсказка:** специальная переменная `RANDOM` не является частью стандарта POSIX. Для получения
случайного числа можно воспользоваться `awk`. Проверьте, что число действительно случайное.

**Файл:** [rand.sh](./src/rand.sh).

## Калькулятор (1 балл)

Реализуйте shell-скрипт, принимающий переменное число аргументов и вычисляющий математическое
выражение в целых числах.

Если аргументов ненулевое количество, выведите на экран результат вычисления выражения,
составленного из всех аргументов, перечисленных через пробел.

Если аргументы не были переданы, считайте одну строку из стандартного потока ввода и вычислите её
как математическое выражение.

**Необходимо использовать:** арифметические выражения, `read`.

**Файл:** [calc.sh](./src/calc.sh).

### Пример

```
$ ./calc.sh 1 + 2
3
$ ./calc.sh
1 + 2
3
```

## Томительное ожидание (1 балл)

Реализуйте shell-скрипт, принимающий в качестве единственного аргумента командной строки путь до
файла с логом сборки и выводящий текущий прогресс сборки на экран.

Файл с логом дописывается параллельно с тем, как выполняется скрипт.

Некоторые строки лога имеют вид `[xx/yy] zzz`.
Для каждой такой строки требуется выводить строку вида `[xx/yy]`.
Не подходящие строки игнорировать.

Скрипт должен выводить новую строку сразу же, как только подходящая строка появляется в файле.
Скрипт не обязан завершаться.

**Необходимо использовать:** `tail` (прочитайте `man tail`), `grep`, пайпы (конвейеры).

**Файл:** [progress.sh](./src/progress.sh).

### Пример

```
$ ./progress.sh build.log
[3/100]
[4/100]
[5/100]
[6/100]
[7/100]
[8/100]
[9/100]
[10/100]
[11/100]
[12/100]
[13/100]
[14/100]
^C
```

### Дополнительное задание (+0,5 балла)

Сделайте вывод не в отдельной строке, а в той же. То есть так, чтобы предыдущий пример вывел:

```
$ ./progress.sh build.log
[14/100]
```

И эта строка обновлялась с появлением новых строк в файле.

Подсказка: используйте `printf` с `\r` или что-нибудь аналогичное (`awk`, `sed`).

## Зеркало (1 балла)

Реализуйте shell-скрипт, принимающий неопределённое количество аргументов и преобразующий
содержимое стандартного потока ввода, выводя результат преобразования на экран.

Каждый аргумент командной строки имеет одно из двух значений:

- `H` — отразить по-горизонтали (справа налево)
- `V` — отразить по-вертикали (снизу вверх)

Скрипт должен применить заданные преобразования в указанном порядке слева направо.

Если не указано ни одного аргумента — выводится в точности то же самое, что было введено.

Если аргумент не соответствует ни одному из перечисленных он игнорируется.

**Необходимо использовать:** `cat`, `tac`, `rev`.

**Файл:** [mirror.sh](./src/mirror.sh).

### Пример

```
$ cat test.txt
ABC
DEF
GHI
$ ./mirror.sh H <test.txt
CBA
FED
IHG
$ ./mirror.sh V <test.txt
GHI
DEF
ABC
$ ./mirror.sh H V <test.txt
IHG
FED
CBA
```

### Дополнительное задание (+1 балл)

Реализуйте с использованием рекурсивной функции и пайпов.

**Подсказка:** для работы с аргументами используйте `shift`.

## Красные линии (1 балл)

Реализуйте shell-скрипт, принимающий ноль или несколько аргументов.

Если аргументов ноль, из стандартного потока ввода считывается текст и на стандартный поток вывода
отправляется тот же самый текст, в котором убраны все пробельные символы в концах строк.

Если аргументов несколько, текст получается из файлов и результат записывается обратно в
файлы (ничего не выводится).

**Необходимо использовать:** только `sed`.

**Файл:** [trim.sh](./src/trim.sh).

### Дополнительное задание (+1 балл)

Пусть скрипт теперь принимает до двух аргументов. Причём если аргументов два, то первый аргумент
обязательно `-d`. Иначе программа завершается с ненулевым кодом возврата.

Если первый аргумент `-d` и аргументов два, то второй аргумент — это путь до директории.
В таком случае скрипт запускается на всех файлах в указанной директории.

**Необходимо использовать:** `find` с опцией `-exec`.

## Homeless (1 балл)

Реализуйте shell-скрипт, выводящий всех пользователей (ID и имя пользователя, разделённые табом),
чья домашняя директория равна `/dev/null`.

Последней строкой выведите число таких пользователей (`Total:`, таб, число).

**Необходимо использовать:** только `awk`.

**Файл:** [homeless.sh](./src/homeless.sh).

### Пример:

```
$ ./homeless.sh
13      man
101     messagebus
300     dhcp
123     ntp
133     rtkit
75      redis
60      mysql
Total:  7
```

### Дополнительное задание (+0,5 балла)

Отсортируйте пользователей по их ID. Строку с количеством необходимо оставить последней.

**Необходимо использовать:** `sort`.

## По линейке (1 балл)

Реализуйте shell-скрипт, подсчитывающий суммарное количество строк во всех обычных (regular) файлах
внутри текущей директории рекурсивно.

**Необходимо использовать:** `find` с опцией `-exec`, `wc`.

**Файл:** [lines.sh](./src/lines.sh).
